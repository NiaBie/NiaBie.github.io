<!-- 通用模板 -->

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <!-- jquery -->
  <script src="https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="https://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>

  
<link rel="stylesheet" href="/css/main.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body onload="my_load()"">

  <div class="web_name_box">
    
  </div>
  
  <!-- 顶部菜单栏 -->

<div class="menu_box shadow_box">
  <div class="menu_item_box left" id="menu_preview">preview</div>
  <div class="menu_item_box left" id="menu_tags">tags</div>
  <div class="menu_item_box left" id="menu_categories">categories</div>

  <div class="search_input_box left" id="search_input_box">
    <input type="search" placeholder="" id="search_input" class="search_input">
  </div>

  <div class="menu_item_box right" id="menu_next">next</div>
  
    <div class="menu_item_box right" id="menu_guide">guide</div>
  
  <div class="menu_item_box right" id="menu_site">sites</div>
</div>

<div class="tag_box shadow_box" id="tag_box"></div>

<div class="category_box shadow_box" id="category_box"></div>

<div class="site_box shadow_box" id="site_box">
  <span class="site_item">
    <a href="/">home</a>
  </span>
  <span class="site_item">
    <a href="/archives">archives</a>
  </span>
  <span class="site_item">
    <a target="_blank" rel="noopener" href="https://github.com/NiaBie">github</a>
  </span>
  <span class="site_item">
    <a href="/knife">knives</a>
  </span>
  <span class="site_item">
    <a href="/friends">links</a>
  </span>
</div>


  <!-- 附加导航 -->
  <div class="guide_box shadow_box" id="guide_box">
    <div class="tag_list_box" id="tag_list_box">
      <span class="guide_item">tags</span>
      
        
      
    </div>

    <div class="line_box" id="guide_line_box"></div>
    <style>
      #guide_line_box {
        width: 90%;
      }
    </style>
    
    <div class="category_list_box" id="category_list_box">
      <span class="guide_item">categories</span>
      
        
          <span class="category_item">
            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
          </span>
        
      
    </div>

    <div class="guide_list_box border_box" id="guide_list_box"></div>
  </div>


<div class="search_result_box shadow_box" id="search_result_box">
  <div id="search_filter" class="search_list_box">
    <span id="search_filter_1" class="search_item">
      <a>only title</a>
    </span>
    <span id="search_filter_2" class="search_item">
      <a>title and content</a>
    </span>
  </div>
  <div id="search_result_list" class="search_result_list"></div>
</div>



<script>
  tags_name = new Array();
  tags_path = new Array();

  ''
    var temp = 'sage';
    tags_name.push(temp);
    temp = 'tags/sage/';
    tags_path.push(temp);
  ''
    var temp = 'python';
    tags_name.push(temp);
    temp = 'tags/python/';
    tags_path.push(temp);
  ''
    var temp = 'android studio';
    tags_name.push(temp);
    temp = 'tags/android-studio/';
    tags_path.push(temp);
  ''
    var temp = 'android';
    tags_name.push(temp);
    temp = 'tags/android/';
    tags_path.push(temp);
  ''
    var temp = 'adb';
    tags_name.push(temp);
    temp = 'tags/adb/';
    tags_path.push(temp);
  ''
    var temp = 'java';
    tags_name.push(temp);
    temp = 'tags/java/';
    tags_path.push(temp);
  ''
    var temp = 'cubism';
    tags_name.push(temp);
    temp = 'tags/cubism/';
    tags_path.push(temp);
  ''
    var temp = 'javascript';
    tags_name.push(temp);
    temp = 'tags/javascript/';
    tags_path.push(temp);
  ''
    var temp = 'live2d';
    tags_name.push(temp);
    temp = 'tags/live2d/';
    tags_path.push(temp);
  ''
    var temp = 'typescript';
    tags_name.push(temp);
    temp = 'tags/typescript/';
    tags_path.push(temp);
  ''
    var temp = 'npm';
    tags_name.push(temp);
    temp = 'tags/npm/';
    tags_path.push(temp);
  ''
    var temp = 'linux';
    tags_name.push(temp);
    temp = 'tags/linux/';
    tags_path.push(temp);
  ''
    var temp = 'powerline';
    tags_name.push(temp);
    temp = 'tags/powerline/';
    tags_path.push(temp);
  ''
    var temp = 'zsh';
    tags_name.push(temp);
    temp = 'tags/zsh/';
    tags_path.push(temp);
  ''
    var temp = 'vim';
    tags_name.push(temp);
    temp = 'tags/vim/';
    tags_path.push(temp);
  ''
    var temp = 'git';
    tags_name.push(temp);
    temp = 'tags/git/';
    tags_path.push(temp);
  ''
    var temp = 'pip';
    tags_name.push(temp);
    temp = 'tags/pip/';
    tags_path.push(temp);
  ''
    var temp = 'gnome';
    tags_name.push(temp);
    temp = 'tags/gnome/';
    tags_path.push(temp);
  ''
    var temp = 'PyQt5';
    tags_name.push(temp);
    temp = 'tags/PyQt5/';
    tags_path.push(temp);
  ''
    var temp = 'c';
    tags_name.push(temp);
    temp = 'tags/c/';
    tags_path.push(temp);
  ''
    var temp = 'makefile';
    tags_name.push(temp);
    temp = 'tags/makefile/';
    tags_path.push(temp);
  ''
    var temp = 'qt';
    tags_name.push(temp);
    temp = 'tags/qt/';
    tags_path.push(temp);
  ''
    var temp = 'cpp';
    tags_name.push(temp);
    temp = 'tags/cpp/';
    tags_path.push(temp);
  ''
    var temp = 'deb';
    tags_name.push(temp);
    temp = 'tags/deb/';
    tags_path.push(temp);
  ''
    var temp = 'debreate';
    tags_name.push(temp);
    temp = 'tags/debreate/';
    tags_path.push(temp);
  ''
    var temp = 'php';
    tags_name.push(temp);
    temp = 'tags/php/';
    tags_path.push(temp);
  ''
    var temp = 'apahce2';
    tags_name.push(temp);
    temp = 'tags/apahce2/';
    tags_path.push(temp);
  ''
    var temp = 'latex';
    tags_name.push(temp);
    temp = 'tags/latex/';
    tags_path.push(temp);
  ''
    var temp = 'html';
    tags_name.push(temp);
    temp = 'tags/html/';
    tags_path.push(temp);
  ''
    var temp = 'css';
    tags_name.push(temp);
    temp = 'tags/css/';
    tags_path.push(temp);
  ''
    var temp = 'bucket';
    tags_name.push(temp);
    temp = 'tags/bucket/';
    tags_path.push(temp);
  ''
    var temp = '七牛云';
    tags_name.push(temp);
    temp = 'tags/七牛云/';
    tags_path.push(temp);
  ''
    var temp = 'cdn';
    tags_name.push(temp);
    temp = 'tags/cdn/';
    tags_path.push(temp);
  ''
    var temp = 'chrome';
    tags_name.push(temp);
    temp = 'tags/chrome/';
    tags_path.push(temp);
  ''
    var temp = 'qqbrowser';
    tags_name.push(temp);
    temp = 'tags/qqbrowser/';
    tags_path.push(temp);
  ''
    var temp = 'cmake';
    tags_name.push(temp);
    temp = 'tags/cmake/';
    tags_path.push(temp);
  ''
    var temp = '正则表达式';
    tags_name.push(temp);
    temp = 'tags/正则表达式/';
    tags_path.push(temp);
  ''
    var temp = 'http';
    tags_name.push(temp);
    temp = 'tags/http/';
    tags_path.push(temp);
  ''
    var temp = 'eigen';
    tags_name.push(temp);
    temp = 'tags/eigen/';
    tags_path.push(temp);
  ''
    var temp = 'gcc';
    tags_name.push(temp);
    temp = 'tags/gcc/';
    tags_path.push(temp);
  ''
    var temp = 'assemly';
    tags_name.push(temp);
    temp = 'tags/assemly/';
    tags_path.push(temp);
  ''
    var temp = 'gdb';
    tags_name.push(temp);
    temp = 'tags/gdb/';
    tags_path.push(temp);
  ''
    var temp = 'ssh';
    tags_name.push(temp);
    temp = 'tags/ssh/';
    tags_path.push(temp);
  ''
    var temp = 'windows';
    tags_name.push(temp);
    temp = 'tags/windows/';
    tags_path.push(temp);
  ''
    var temp = 'grub';
    tags_name.push(temp);
    temp = 'tags/grub/';
    tags_path.push(temp);
  ''
    var temp = 'hexo';
    tags_name.push(temp);
    temp = 'tags/hexo/';
    tags_path.push(temp);
  ''
    var temp = 'swig';
    tags_name.push(temp);
    temp = 'tags/swig/';
    tags_path.push(temp);
  ''
    var temp = 'ejs';
    tags_name.push(temp);
    temp = 'tags/ejs/';
    tags_path.push(temp);
  ''
    var temp = 'mathjax';
    tags_name.push(temp);
    temp = 'tags/mathjax/';
    tags_path.push(temp);
  ''
    var temp = 'katex';
    tags_name.push(temp);
    temp = 'tags/katex/';
    tags_path.push(temp);
  ''
    var temp = '阿里云';
    tags_name.push(temp);
    temp = 'tags/阿里云/';
    tags_path.push(temp);
  ''
    var temp = 'shell';
    tags_name.push(temp);
    temp = 'tags/shell/';
    tags_path.push(temp);
  ''
    var temp = 'jni';
    tags_name.push(temp);
    temp = 'tags/jni/';
    tags_path.push(temp);
  ''
    var temp = 'ndk';
    tags_name.push(temp);
    temp = 'tags/ndk/';
    tags_path.push(temp);
  ''
    var temp = 'opencv';
    tags_name.push(temp);
    temp = 'tags/opencv/';
    tags_path.push(temp);
  ''
    var temp = 'jsdelivr';
    tags_name.push(temp);
    temp = 'tags/jsdelivr/';
    tags_path.push(temp);
  ''
    var temp = 'jquery';
    tags_name.push(temp);
    temp = 'tags/jquery/';
    tags_path.push(temp);
  ''
    var temp = 'krita';
    tags_name.push(temp);
    temp = 'tags/krita/';
    tags_path.push(temp);
  ''
    var temp = 'mac';
    tags_name.push(temp);
    temp = 'tags/mac/';
    tags_path.push(temp);
  ''
    var temp = 'brew';
    tags_name.push(temp);
    temp = 'tags/brew/';
    tags_path.push(temp);
  ''
    var temp = 'visual studio';
    tags_name.push(temp);
    temp = 'tags/visual-studio/';
    tags_path.push(temp);
  ''
    var temp = 'csharp';
    tags_name.push(temp);
    temp = 'tags/csharp/';
    tags_path.push(temp);
  ''
    var temp = 'mysql';
    tags_name.push(temp);
    temp = 'tags/mysql/';
    tags_path.push(temp);
  ''
    var temp = 'sql';
    tags_name.push(temp);
    temp = 'tags/sql/';
    tags_path.push(temp);
  ''
    var temp = 'unpkg';
    tags_name.push(temp);
    temp = 'tags/unpkg/';
    tags_path.push(temp);
  ''
    var temp = 'bfs';
    tags_name.push(temp);
    temp = 'tags/bfs/';
    tags_path.push(temp);
  ''
    var temp = 'dfs';
    tags_name.push(temp);
    temp = 'tags/dfs/';
    tags_path.push(temp);
  ''
    var temp = 'dijkstra算法';
    tags_name.push(temp);
    temp = 'tags/dijkstra算法/';
    tags_path.push(temp);
  ''
    var temp = 'dinic算法';
    tags_name.push(temp);
    temp = 'tags/dinic算法/';
    tags_path.push(temp);
  ''
    var temp = 'ek算法';
    tags_name.push(temp);
    temp = 'tags/ek算法/';
    tags_path.push(temp);
  ''
    var temp = 'floyd算法';
    tags_name.push(temp);
    temp = 'tags/floyd算法/';
    tags_path.push(temp);
  ''
    var temp = 'km算法';
    tags_name.push(temp);
    temp = 'tags/km算法/';
    tags_path.push(temp);
  ''
    var temp = 'kmp算法';
    tags_name.push(temp);
    temp = 'tags/kmp算法/';
    tags_path.push(temp);
  ''
    var temp = 'kruskal算法';
    tags_name.push(temp);
    temp = 'tags/kruskal算法/';
    tags_path.push(temp);
  ''
    var temp = 'morris算法';
    tags_name.push(temp);
    temp = 'tags/morris算法/';
    tags_path.push(temp);
  ''
    var temp = 'prim算法';
    tags_name.push(temp);
    temp = 'tags/prim算法/';
    tags_path.push(temp);
  ''
    var temp = 'tarjan算法';
    tags_name.push(temp);
    temp = 'tags/tarjan算法/';
    tags_path.push(temp);
  ''
    var temp = '树的遍历';
    tags_name.push(temp);
    temp = 'tags/树的遍历/';
    tags_path.push(temp);
  ''
    var temp = '匈牙利算法';
    tags_name.push(temp);
    temp = 'tags/匈牙利算法/';
    tags_path.push(temp);
  ''
    var temp = 'photoshop';
    tags_name.push(temp);
    temp = 'tags/photoshop/';
    tags_path.push(temp);
  ''
    var temp = '绘画';
    tags_name.push(temp);
    temp = 'tags/绘画/';
    tags_path.push(temp);
  ''
    var temp = 'numpy';
    tags_name.push(temp);
    temp = 'tags/numpy/';
    tags_path.push(temp);
  ''
    var temp = 'sklearn';
    tags_name.push(temp);
    temp = 'tags/sklearn/';
    tags_path.push(temp);
  ''
    var temp = 'matplotlib';
    tags_name.push(temp);
    temp = 'tags/matplotlib/';
    tags_path.push(temp);
  ''
    var temp = 'slenium';
    tags_name.push(temp);
    temp = 'tags/slenium/';
    tags_path.push(temp);
  ''
    var temp = 'phantomjs';
    tags_name.push(temp);
    temp = 'tags/phantomjs/';
    tags_path.push(temp);
  ''
    var temp = 'rss';
    tags_name.push(temp);
    temp = 'tags/rss/';
    tags_path.push(temp);
  ''
    var temp = 'xml';
    tags_name.push(temp);
    temp = 'tags/xml/';
    tags_path.push(temp);
  ''
    var temp = '爬虫';
    tags_name.push(temp);
    temp = 'tags/爬虫/';
    tags_path.push(temp);
  ''
    var temp = 'ajax';
    tags_name.push(temp);
    temp = 'tags/ajax/';
    tags_path.push(temp);
  ''
    var temp = 'termux';
    tags_name.push(temp);
    temp = 'tags/termux/';
    tags_path.push(temp);
  ''
    var temp = '内网穿透';
    tags_name.push(temp);
    temp = 'tags/内网穿透/';
    tags_path.push(temp);
  ''
    var temp = 'stitch';
    tags_name.push(temp);
    temp = 'tags/stitch/';
    tags_path.push(temp);
  ''
    var temp = 'sublime';
    tags_name.push(temp);
    temp = 'tags/sublime/';
    tags_path.push(temp);
  ''
    var temp = 'svg';
    tags_name.push(temp);
    temp = 'tags/svg/';
    tags_path.push(temp);
  ''
    var temp = 'tmux';
    tags_name.push(temp);
    temp = 'tags/tmux/';
    tags_path.push(temp);
  ''
    var temp = 'ubuntu';
    tags_name.push(temp);
    temp = 'tags/ubuntu/';
    tags_path.push(temp);
  ''
    var temp = 'wlan';
    tags_name.push(temp);
    temp = 'tags/wlan/';
    tags_path.push(temp);
  ''
    var temp = 'midi';
    tags_name.push(temp);
    temp = 'tags/midi/';
    tags_path.push(temp);
  ''
    var temp = 'lol';
    tags_name.push(temp);
    temp = 'tags/lol/';
    tags_path.push(temp);
  ''
    var temp = 'hyper';
    tags_name.push(temp);
    temp = 'tags/hyper/';
    tags_path.push(temp);
  ''
    var temp = 'vpn';
    tags_name.push(temp);
    temp = 'tags/vpn/';
    tags_path.push(temp);
  ''
    var temp = 'shadowsocks';
    tags_name.push(temp);
    temp = 'tags/shadowsocks/';
    tags_path.push(temp);
  ''
    var temp = 'ssr';
    tags_name.push(temp);
    temp = 'tags/ssr/';
    tags_path.push(temp);
  ''
    var temp = '驱动';
    tags_name.push(temp);
    temp = 'tags/驱动/';
    tags_path.push(temp);
  ''
    var temp = 'vlfeat';
    tags_name.push(temp);
    temp = 'tags/vlfeat/';
    tags_path.push(temp);
  ''
    var temp = 'vscode';
    tags_name.push(temp);
    temp = 'tags/vscode/';
    tags_path.push(temp);
  ''
    var temp = 'vundle';
    tags_name.push(temp);
    temp = 'tags/vundle/';
    tags_path.push(temp);
  ''
    var temp = 'wegame';
    tags_name.push(temp);
    temp = 'tags/wegame/';
    tags_path.push(temp);
  ''
    var temp = 'mathematica';
    tags_name.push(temp);
    temp = 'tags/mathematica/';
    tags_path.push(temp);
  ''
    var temp = 'wordpress';
    tags_name.push(temp);
    temp = 'tags/wordpress/';
    tags_path.push(temp);
  ''
    var temp = 'apache';
    tags_name.push(temp);
    temp = 'tags/apache/';
    tags_path.push(temp);
  ''
    var temp = 'xampp';
    tags_name.push(temp);
    temp = 'tags/xampp/';
    tags_path.push(temp);
  ''
    var temp = '百度网盘';
    tags_name.push(temp);
    temp = 'tags/百度网盘/';
    tags_path.push(temp);
  ''
    var temp = 'sai';
    tags_name.push(temp);
    temp = 'tags/sai/';
    tags_path.push(temp);
  ''
    var temp = 'medibang paint';
    tags_name.push(temp);
    temp = 'tags/medibang-paint/';
    tags_path.push(temp);
  ''
    var temp = 'gradle';
    tags_name.push(temp);
    temp = 'tags/gradle/';
    tags_path.push(temp);
  ''
    var temp = 'javacv';
    tags_name.push(temp);
    temp = 'tags/javacv/';
    tags_path.push(temp);
  ''
    var temp = '微电子';
    tags_name.push(temp);
    temp = 'tags/微电子/';
    tags_path.push(temp);
  ''
  // 因为path和name只有前缀不同,所以分别排序之后相对顺序还是一样的
  tags_name.sort();
  tags_path.sort();
  for (var i = 0; i < tags_name.length; i ++)
  {
    $("#tag_box").append("<span class='tag_item'><a href='/" + tags_path[i] + "'>" + tags_name[i] + "</a></span>\n");
  }


  categories_name = new Array();
  categories_path = new Array();

  ''
    var temp = '问题求解';
    categories_name.push(temp);
    temp = 'categories/问题求解/';
    categories_path.push(temp);
  ''
    var temp = '操作系统';
    categories_name.push(temp);
    temp = 'categories/操作系统/';
    categories_path.push(temp);
  ''
    var temp = '微电子';
    categories_name.push(temp);
    temp = 'categories/微电子/';
    categories_path.push(temp);
  ''
    var temp = '数据库';
    categories_name.push(temp);
    temp = 'categories/数据库/';
    categories_path.push(temp);
  ''
    var temp = '数据通信';
    categories_name.push(temp);
    temp = 'categories/数据通信/';
    categories_path.push(temp);
  ''
    var temp = '数理逻辑';
    categories_name.push(temp);
    temp = 'categories/数理逻辑/';
    categories_path.push(temp);
  ''
    var temp = '概率论与数理统计';
    categories_name.push(temp);
    temp = 'categories/概率论与数理统计/';
    categories_path.push(temp);
  ''
    var temp = '计算机网络';
    categories_name.push(temp);
    temp = 'categories/计算机网络/';
    categories_path.push(temp);
  ''
  // 因为path和name只有前缀不同,所以分别排序之后相对顺序还是一样的
  categories_name.sort();
  categories_path.sort();
  for (var i = 0; i < categories_name.length; i ++)
  {
    $("#category_box").append("<span class='category_item'><a href='/" + categories_path[i] + "'>" + categories_name[i] + "</a></span>\n");
  }
</script>

<script>
  // TODO 搜索
</script>
  <!-- latex公式渲染 -->



<script>
  document.temp_latex = '2';// 全局变量,latex公式渲染方式
</script>



<!-- katex -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hexo-simple-theme/hexo_latex@1.0.0/katex/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/gh/hexo-simple-theme/hexo_latex@1.0.0/katex/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/gh/hexo-simple-theme/hexo_latex@1.0.0/katex/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>

<script>
  console.log("katex rendering");
  // 删除<p>内部换行,使katex正确渲染
  $(document).ready(setTimeout(function()
  {
    var possible_position =  new Array(".main_box p", "main_box li");
    for (i in possible_position) {
      var all_text = document.querySelectorAll(possible_position[i]);
      all_text.forEach(function(temp_p) {
        temp_p.innerHTML = temp_p.innerHTML.replace(/<br>/g, "&nbsp;");// 手动清除换行
      });
    }

    // 渲染latex公式
    renderMathInElement(document.body,
    {
      // ...options...
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
        // { left: "\\[", right: "\\]", display: true }
      ]
    });

    // 删除latex公式里面的回车
    var all_katex = document.querySelectorAll(".katex");
    all_katex.forEach(function(temp_p) {
      temp_p.innerHTML = temp_p.innerHTML.replace(/&nbsp;/g, "");
    });

    // 恢复回车
    for (i in possible_position) {
      var all_text = document.querySelectorAll(possible_position[i]);
      all_text.forEach(function(temp_p) {
        temp_p.innerHTML = temp_p.innerHTML.replace(/&nbsp;/g, "<br>");
      });
    }
  }, 500));// 删除元素不能进行得太早,不然会和highlight的dfs冲突
</script>


  <!-- 文章 -->

<div class="main_box border_box">
  <span class="post_title" id="post_title">计算机网络</span>
  <br>
  <span class="post_date">2019-12-23</span>
  
  <div class="line_box" id="post_line_box"></div>
  <style>
    #post_line_box {
      width: 100%;
      margin-top: 10px;
    }
  </style>

  <h1 id="1-计算机网络和因特网"><a href="#1-计算机网络和因特网" class="headerlink" title="1 计算机网络和因特网"></a>1 计算机网络和因特网</h1><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><h2 id="1-4-分组交换网中的时延-丢包和吞吐量"><a href="#1-4-分组交换网中的时延-丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延,丢包和吞吐量"></a>1.4 分组交换网中的时延,丢包和吞吐量</h2><p>节点总时延($d_{nodal}$)=节点处理时延($d_{proc}$)+排队时延($d_{queue}$)+传输时延($d_{trans}$)+传播时延($d_{prop}$)</p>
<h3 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h3><ul>
<li>流量强度</li>
</ul>
<h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2><h3 id="1-5-1-分层的体系结构"><a href="#1-5-1-分层的体系结构" class="headerlink" title="1.5.1 分层的体系结构"></a>1.5.1 分层的体系结构</h3><ol>
<li>协议分层<ol>
<li>应用层<br>http,smtp,ftp</li>
<li>运输层<br>tcp,udp</li>
<li>网络层<br>ip</li>
<li>链路层<br>CSMA,CSMA/CD,<em>CSMA/CA</em></li>
<li>物理层</li>
</ol>
</li>
</ol>
<h3 id="1-5-2-封装"><a href="#1-5-2-封装" class="headerlink" title="1.5.2 封装"></a>1.5.2 封装</h3><ul>
<li><p>应用层报文</p>
</li>
<li><p>运输层报文段</p>
</li>
<li><p>网络层数据报</p>
</li>
<li><p>链路层帧</p>
</li>
<li><p>有效载荷字段</p>
</li>
</ul>
<h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3 运输层"></a>3 运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p>运输层协议死在端系统中而不是在路由器中实现的.在发送端,运输层将接收到的报文转换成运输层分组,该分组称为运输层<strong>报文段(segment)</strong></p>
<h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><p>网络层提供了<strong>主机</strong>之间的逻辑通信,而运输层为运行在不同主机上的进程之间提供了逻辑通信</p>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><ul>
<li><p>UDP(用户数据报协议):他为调用它的应用程序提供了一种不可靠,无连接的服务</p>
</li>
<li><p>TCP(传输控制协议):他为调用它的应用程序提供了一种可靠的,面向连接的服务</p>
</li>
</ul>
<p>将TCP和UDP的分组统称为<strong>报文段(segment)</strong>,而将**数据报(datagram)**名称留给网络层分组</p>
<p>ip的服务模型时<strong>尽力而为交付服务(best-effort delivery service)</strong>.这意味着ip尽他最大的努力在通信的主机之间交付报文段,<strong>但他并不作任何确保</strong>.特别是不确保报文段的交付,不保证报文段的按序交付,不保证报文段中数据的完整性.由于这些原因,ip被称为<strong>不可靠服务</strong></p>
<h2 id="3-2-多路复用与多路分解-概念"><a href="#3-2-多路复用与多路分解-概念" class="headerlink" title="3.2 多路复用与多路分解(概念)"></a>3.2 多路复用与多路分解(概念)</h2><p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>(demultiplexing)</p>
<p>在源主机从不同套接字中收集数据块,并未每个数据块封装上首部信息(将在以后用于分解)从而生成报文段,然后将报文段传递到网络层,所有这些工作称为<strong>多路复用</strong>(multiplexing)</p>
<h2 id="3-3-无连接运输-UDP-概念"><a href="#3-3-无连接运输-UDP-概念" class="headerlink" title="3.3 无连接运输:UDP(概念)"></a>3.3 无连接运输:UDP(概念)</h2><p>有许多应用更适合用UDP,原因主要以下几点</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细</li>
<li>无需连接建立</li>
<li>无连接状态</li>
<li>分组首部开销小</li>
</ul>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><ul>
<li>周知端口号(well-known port):0-1023</li>
</ul>
<p><img src="/img/udp.png"></p>
<ul>
<li>其他首部字段<ul>
<li>长度:2字节</li>
<li>校验和:2字节</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-UDP校验和"><a href="#3-3-2-UDP校验和" class="headerlink" title="3.3.2 UDP校验和"></a>3.3.2 UDP校验和</h3><h2 id="3-5-面向连接的运输-TCP"><a href="#3-5-面向连接的运输-TCP" class="headerlink" title="3.5 面向连接的运输:TCP"></a>3.5 面向连接的运输:TCP</h2><h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1 TCP连接"></a>3.5.1 TCP连接</h3><p>TCP连接提供的是<strong>全双工服务</strong>:如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接,那么应用层数据就可在从进程B流向进程A的同事,也从进程A流向进程B</p>
<p>发起连接的进程被称为<strong>客户进程</strong>,另一个进程被称为<strong>服务器进程</strong></p>
<p>TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度(MSS)</strong>.MSS通常根据最初确定的有本地发送主机发送的最大链路层帧长度(即<strong>最大传输单元(MTU)</strong>)来设置.MSS是指在报文段里应用层数据的最大长度,而不是只包括首部的TCP报文段的最大长度</p>
<p>TCP为每块客户数据配上一个TCP首部,从而形成对个<strong>TCP报文段</strong>.这些报文段被下传给网络层,网络层间期分别封装在网络层ip数据包中</p>
<h3 id="3-5-2-TCP报文段结构"><a href="#3-5-2-TCP报文段结构" class="headerlink" title="3.5.2 TCP报文段结构"></a>3.5.2 TCP报文段结构</h3><p><img src="/img/tcp.png"></p>
<ul>
<li>序号字段,确认号字段:见后</li>
<li>接收窗口字段:见流量控制</li>
<li>首部长度字段:TCP首部长度/32比特.由于TCP选项字段,TCP首部的长度是可变的(通常选项字段为空,TCP首部的典型长度为20字节)</li>
<li>选项字段:在发送方与接收方协商最大报文段长度(MSS)时,或在高速网络环境下用作窗口调节因子时使用</li>
<li>标志字段<ul>
<li>ACK:指示确认字段中的值是有效的,即该报文段包括一个对已被成功接收报文段的确认</li>
<li>RST,SYN,FIN:用于连接建立和拆除,见后</li>
<li>CWR,ECE:明确拥塞通告</li>
<li>PSH:指示接收方应立即将数据交给上层</li>
<li>URG:指示报文段里存在着被发送端的上层实体置为<code>紧急</code>的数据,紧急数据的最后一个字节由16bit的<strong>紧急数据指针字段</strong>指出</li>
</ul>
</li>
</ul>
<ol>
<li><p>序号和确认号<br>序号时建立在传送的字节流之上,而<strong>不是</strong>建立在传送的报文段的序列之上的.<strong>一个报文段的序号</strong>(sequence number for a segment)因此事该报文段首字节的字节流编号<br>主机A在向主机B发送数据的同事,也许也接受来自主机B的数据.主机A填充进报文段的确认号时主机A期望从主机B收到的下一字节的序号<br>假设主机A收到来自主机B包含字节0-535和900-1000的报文段,没有收到536-899的报文段.主机A为了重新构建主机B的数据流,仍在等待字节536,因此A到B的下一个报文段将在确认号字段中包含536.引文TCP只确认该流中至第一个丢失字节为止的字节,所以TCP被称为提供<strong>累积确认</strong><br>当主机在一条TCP连接中收到失序报文段</p>
<ol>
<li>接收方立即丢弃失序报文段</li>
<li>(实践中采用)接收方保留失序的字节,并等待缺少的字节以填补该间隔</li>
</ol>
</li>
<li><p>Telnet案例</p>
</li>
</ol>
<h3 id="3-5-3-往返时间的估计与超时"><a href="#3-5-3-往返时间的估计与超时" class="headerlink" title="3.5.3 往返时间的估计与超时"></a>3.5.3 往返时间的估计与超时</h3><ul>
<li>往返时间(RTT)</li>
</ul>
<ol>
<li><p>估计往返时间<br>大多数TCP的实现仅在某个时刻做一次SampleRTT测量,而不是为每个发送的报文段测量一个SampleRTT<br>$EstimatedRTT=(1-\alpha)\cdot EstimatedRTT+\alpha\cdot SampleRTT$</p>
<ul>
<li>指数加权移动平均(EWMA):一个给定的SampleRTT的权值在更新的过程中呈指数型快速衰减<br>RTT偏差DevRTT,用于估算SampleRTT一般会偏离EstimatedRTT的程度:<br>$DevRTT=(1-\beta)\cdot DevRTT+\beta\cdot|SampleRTT-EstimatedRTT|$</li>
</ul>
</li>
<li><p>设置和管理重传超时间隔<br>$TimeoutInterval=EstimatedRTT+4\cdot DevRTT$<br>当出现超时后,TimeoutInterval值将加倍,以免即将被确认的后继报文段过早出现超时.只要收到报文段并更新EstimatedRTT,就使用上述公式再次计算TimeoutInterval</p>
</li>
</ol>
<h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4 可靠数据传输"></a>3.5.4 可靠数据传输</h3><p>推荐的定时器管理过程仅使用<strong>单一</strong>的重传定时器</p>
<ul>
<li>TCP发送方的3个与发送和重传有关的主要事件<ul>
<li>从上层应用程序接收数据</li>
<li>超时事件</li>
<li>到达一个来自接收方的包含了有效ACK字段值的报文段</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>超时间隔加倍<br>每次TCP重传时都会将下一次的超时间隔设为先前值的两倍</p>
</li>
<li><p>快速重传</p>
<table>
<thead>
<tr>
<th align="center">事件</th>
<th align="center">TCP接收方动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">具有所期望序号的按序报文段到达.所有在期望序号及以前的数据都已经被确认</td>
<td align="center">延迟的ACK.对另一个按序报文段的到达最多等待500ms.如果下一个按序报文段在这个时间间隔内没有到达,则发送一个ACK(合并ACK,降低网络流量)</td>
</tr>
<tr>
<td align="center">具有所期望序号的按序报文段到达.另一个按序报文段<strong>等待</strong>ACK传输</td>
<td align="center">立即发送单个累计ACK,以确认两个按序报文段</td>
</tr>
<tr>
<td align="center">比期望序号大的失序报文段到达.检测出间隔</td>
<td align="center">立即发送冗余ACK,指示下一个期待字节的序号(为间隔的低端的序号)</td>
</tr>
<tr>
<td align="center">能部分或完全填充接收数据间隔的报文段到达</td>
<td align="center">若该报文段起始于间隔的低端,则立即发送ACK</td>
</tr>
</tbody></table>
</li>
</ol>
<p>一旦收到3个冗余ACK,TCP就执行<strong>快速重传</strong></p>
<ol start="4">
<li>回退$N$步还是选择重传<br>选择确认:TCP接收方有选择地确认失序报文段,而不是累积地确认最后一个正确接收的有序报文段<br>选择重传机制:跳过重传那些已被接收方选择性地确认过的报文段</li>
</ol>
<h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><ul>
<li><p>流量控制服务</p>
</li>
<li><p><em>拥塞控制</em></p>
</li>
</ul>
<p>TCP通过让<strong>发送方</strong>维护一个称为<strong>接收窗口</strong>的变量来提供流量控制.假设主机A通过一条TCP连接向主机B发送一个大文件,定义以下变量</p>
<ul>
<li>RcvBuffer:主机B为该连接分配的接收缓存的大小</li>
<li>LastByteRead:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号</li>
<li>LastByteRcvd:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号</li>
</ul>
<p>由于TCP不允许已分配的缓存溢出,下式必须成立<br>$LastByteRcvd-LastByteRead\le RcvBuffer$<br>接收窗口用rwnd表示(空闲空间)<br>$rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]$</p>
<p>主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中,通知主机A缓存中还有多少可用空间</p>
<p>主机A轮流跟踪2个变量LastByteSent,LastByteAcked,这两个变量之间的差LastByteSent-LastByteAcked就是主机A发送到连接中但未被确认的数据量.通过将未确认的数据量控制在rwnd以内,就可以保证主机A不会使主机B的接收缓存溢出.因此主机A必须保证$LastByteSent-LastByteAcked\le rwnd$</p>
<p>当主机B的接收窗口为0时,主机A继续发送只有一个字节数据的报文段.这些报文段将会被接收方确认.最终缓存将开始清空,并且确认报文里将包含一个非0的rwnd值</p>
<p>UDP并不提供流量控制,报文段由于缓存溢出可能在接收方丢失</p>
<h3 id="3-5-6-TCP连接管理"><a href="#3-5-6-TCP连接管理" class="headerlink" title="3.5.6 TCP连接管理"></a>3.5.6 TCP连接管理</h3><h2 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h2><h3 id="3-6-1-拥塞原因与代价"><a href="#3-6-1-拥塞原因与代价" class="headerlink" title="3.6.1 拥塞原因与代价"></a>3.6.1 拥塞原因与代价</h3><h4 id="两个发送方和一台具有无穷大缓存的路由器"><a href="#两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="两个发送方和一台具有无穷大缓存的路由器"></a>两个发送方和一台具有无穷大缓存的路由器</h4><p>当分组的到达速率接近链路容量时,分组经历巨大的排队时延</p>
<h4 id="两个发送方和一台具有有限缓存的路由器"><a href="#两个发送方和一台具有有限缓存的路由器" class="headerlink" title="两个发送方和一台具有有限缓存的路由器"></a>两个发送方和一台具有有限缓存的路由器</h4><p>用$\lambda_{in}$字节/秒表示应用程序将初始数据发送到套接字中的速率.运输层向网络中发送报文段(含有初始数据或重传数据)的速率用$\lambda_{in}’$字节/秒表示,$\lambda_{in}’$有时被称为网络的<strong>供给载荷</strong></p>
<h3 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2 拥塞控制方法"></a>3.6.2 拥塞控制方法</h3><h2 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h2><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><h3 id="TCP拥塞控制-回顾"><a href="#TCP拥塞控制-回顾" class="headerlink" title="TCP拥塞控制:回顾"></a>TCP拥塞控制:回顾</h3><h3 id="对TCP吞吐量的宏观描述"><a href="#对TCP吞吐量的宏观描述" class="headerlink" title="对TCP吞吐量的宏观描述"></a>对TCP吞吐量的宏观描述</h3><h3 id="3-7-1-公平性"><a href="#3-7-1-公平性" class="headerlink" title="3.7.1 公平性"></a>3.7.1 公平性</h3><h3 id="3-7-2-明确拥塞通告-网络辅助拥塞控制"><a href="#3-7-2-明确拥塞通告-网络辅助拥塞控制" class="headerlink" title="3.7.2 明确拥塞通告:网络辅助拥塞控制"></a>3.7.2 明确拥塞通告:网络辅助拥塞控制</h3><h1 id="4-网络层-数据平面"><a href="#4-网络层-数据平面" class="headerlink" title="4 网络层:数据平面"></a>4 网络层:数据平面</h1><h2 id="4-2-路由器工作原理-关键"><a href="#4-2-路由器工作原理-关键" class="headerlink" title="4.2 路由器工作原理(关键)"></a>4.2 路由器工作原理(关键)</h2><h3 id="4-2-1-输入端口处理和基于目的地转发"><a href="#4-2-1-输入端口处理和基于目的地转发" class="headerlink" title="4.2.1 输入端口处理和基于目的地转发"></a>4.2.1 输入端口处理和基于目的地转发</h3><ul>
<li><p>前缀(prefix)</p>
</li>
<li><p>最长前缀匹配规则(longest prefix matching rule):在转发表(forwarding table)中寻找最长的匹配项,冰箱与最长前缀匹配相关联的链路接口转发分组</p>
</li>
</ul>
<h3 id="4-2-2-交换"><a href="#4-2-2-交换" class="headerlink" title="4.2.2 交换"></a>4.2.2 交换</h3><h3 id="4-2-3-输出端口处理"><a href="#4-2-3-输出端口处理" class="headerlink" title="4.2.3 输出端口处理"></a>4.2.3 输出端口处理</h3><h3 id="4-2-4-何处出现排队"><a href="#4-2-4-何处出现排队" class="headerlink" title="4.2.4 何处出现排队"></a>4.2.4 何处出现排队</h3><ol>
<li><p>输入排队</p>
</li>
<li><p>输出排队</p>
</li>
</ol>
<h3 id="4-2-5-分组调度-packet-scheduler"><a href="#4-2-5-分组调度-packet-scheduler" class="headerlink" title="4.2.5 分组调度(packet scheduler)"></a>4.2.5 分组调度(packet scheduler)</h3><ol>
<li><p>先进先出(FIFO,也称为先来先服务,FCFS)</p>
</li>
<li><p>优先权排队(priority queuing)<br>每个优先权类通常都有自己的队列.当选择一个分组传输时,优先权排队规则将从队列为飞空的最高优先权类中传输一个分组.在<strong>同一优先权类</strong>的分组之间的选择通常以FIFO方式完成</p>
<ul>
<li>非抢占式优先权排队<br>一旦分组开始传输,就不能打断</li>
</ul>
</li>
<li><p>循环排队规则</p>
</li>
<li><p>加权公平排队(Weighted Fair Queuing, WFQ)</p>
</li>
</ol>
<h2 id="4-3-网际协议-关键"><a href="#4-3-网际协议-关键" class="headerlink" title="4.3 网际协议(关键)"></a>4.3 网际协议(关键)</h2><h3 id="4-3-1-IPv4数据报格式"><a href="#4-3-1-IPv4数据报格式" class="headerlink" title="4.3.1 IPv4数据报格式"></a>4.3.1 IPv4数据报格式</h3><p><img src="/img/ipv4.png"></p>
<ul>
<li><p>版本号:不同的ip版本使用不同的数据报格式</p>
</li>
<li><p>首部长度</p>
</li>
<li><p>服务类型(TOS):以便不同类型的ip数据报能相互区别开来<br>见3.7.2(网络辅助拥塞控制),9.5.2.1(促进思考的场景),9.5.3(区分服务)</p>
</li>
<li><p>数据包长度:ip数据包的总长度(首部加上数据),以字节计</p>
</li>
<li><p>标识,标志,片偏移:<em>见后</em></p>
</li>
<li><p>寿命(TTL):每当一台路由器处理数据报时,该字段的值-1.若TTL字段减为0,则该数据报必须丢弃</p>
</li>
<li><p>上层协议:指示了ip数据报的数据部分应交给哪个特定的运输层协议</p>
</li>
<li><p>首部检验和</p>
</li>
<li><p>源ip地址</p>
</li>
<li><p>目的ip地址</p>
</li>
<li><p>选项</p>
</li>
<li><p>数据</p>
</li>
</ul>
<h3 id="4-3-2-IPv4数据报分片"><a href="#4-3-2-IPv4数据报分片" class="headerlink" title="4.3.2 IPv4数据报分片"></a>4.3.2 IPv4数据报分片</h3><ul>
<li><p>最大传送单元(Maximum Transimission Unit, MTU)</p>
</li>
<li><p>片(fragment)</p>
</li>
</ul>
<p>IPv4的设计者将数据报的重新组装工作放到端系统中,而不是放到网络路由器中</p>
<ul>
<li><p>标识:当生成一个数据报时,发送主机在为数据报设置标识号,通常将发送的每个数据报的标识号+1</p>
</li>
<li><p>标志:最后一个片的标志比特设为0,所有其他片的标志比特设为1</p>
</li>
<li><p>片偏移:指定该片应放在初始ip数据报的哪个位置</p>
</li>
</ul>
<h3 id="4-3-3-IPv4编址"><a href="#4-3-3-IPv4编址" class="headerlink" title="4.3.3 IPv4编址"></a>4.3.3 IPv4编址</h3><ul>
<li><p>接口:主机与物理链路之间的边界叫做接口,路由器与它的任意一条链路之间的边界也叫做接口.ip要求每台主机和路由器接口拥有自己的ip地址.因此,一个ip地址与一个<strong>接口</strong>相关联,而不是与包括该接口的主机或路由器相关联</p>
</li>
<li><p>子网(subnet):互联主机接口与路由器接口的网络形成一个子网.分开主机和路由器的每个接口,产生几个隔离的网络岛,使用接口端接这些隔离的网络的端点,这些隔离的网络中的每一个都叫做一个子网</p>
</li>
<li><p>子网掩码(network mask):指示32比特中的最左侧$x$比特定义了子网地址</p>
</li>
<li><p>前缀(prefix)(或网络前缀):形式为$a.b.c.d/x$的地址的$x$最高比特构成了ip地址的网络部分,并且经常被称为该地址的前缀</p>
</li>
<li><p>无类别域间路由选择(Classless Interdomain Routing, CIDR)</p>
</li>
<li><p>分类编址(classful addressing),ABC类网络</p>
</li>
<li><p>广播地址:当一台主机发出一个目的地址为255.255.255.255的数据报时,该报文会交付给同一个网络中的所有主机</p>
</li>
</ul>
<ol>
<li><p>获取一块地址</p>
</li>
<li><p>获取主机地址:动态主机配置协议</p>
<ul>
<li>动态主机配置协议(Dynamic Host Configuration, DHCP):<br>网络管理员能够配置DHCP,使某给定主机每次与网络连接时能得到一个相同的ip地址,或者某主机将被分配一个<strong>临时的ip地址</strong>,每次与网络连接时该地址也许是不同的<br>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力,故他又常被称为<strong>即插即用协议</strong>或<strong>零配置协议</strong><br>对于一台新到达的主机而言,DHCP协议是一个4个步骤的过程<ul>
<li>DHCP服务器发现:客户在UDP分组中向端口67发送发现报文,该UDP分组封装在一个ip数据报中,使用广播目的地址255.255.255.255并且使用源ip地址0.0.0.0.DHCP客户将该ip数据报传递给链路层,链路层然后将该帧广播到所有与该子网连接的节点</li>
<li>DHCP服务器提供:DHCP服务器收到一个DHCP发现报文时,用<strong>DHCP提供报文</strong>向客户做出响应,该报文向该子网的所有节点广播,仍然使用ip广播地址255.255.255.255.每台服务器提供的报文包含有收到的发现报文的事务id,向客户推荐的ip地址,网络掩码以及<strong>ip地址租用期</strong>,服务器租用期通常设置为几小时或几天</li>
<li>DHCP请求:客户从一个或多个服务器提供中选择一个,并向选中的服务器提供用<strong>DHCP请求报文</strong>进行响应,回显配置的参数</li>
<li>DHCP ACK:服务器用<strong>DHCP ACK报文</strong>对DHCP请求报文进行响应,证实所要求的参数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-3-4-网络地址转换-NAT"><a href="#4-3-4-网络地址转换-NAT" class="headerlink" title="4.3.4 网络地址转换(NAT)"></a>4.3.4 网络地址转换(NAT)</h3><ul>
<li>NAT转换表</li>
</ul>
<h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3><p><img src="/img/ipv6.png"></p>
<ol>
<li><p>IPv6数据报格式</p>
<ul>
<li>IPv6定义的字段<ul>
<li>版本:IPv6将该字段值设为6</li>
<li>流量类型:与IPv4的TOS相似</li>
<li>流标签:用于标识一条数据报的流,能够对一条流中的某些数据报给出优先权</li>
<li>有效载荷长度:IPv6数据报中跟在定长40字节数据报首部后面的字节数量</li>
<li>下一个首部:标识数据报中的内容(数据字段)需要交付给哪个协议.该字段使用与IPv4首部中协议字段相同的值</li>
<li>跳限制:转发数据报的每台路由器将对该字段的内容-1.如果跳限制计数达到0,则该数据报将被丢弃</li>
<li>数据</li>
</ul>
</li>
<li>IPv6的变化</li>
<li>IPv6舍弃的字段<ul>
<li>分片/重新组装:IPv6不允许在中间路由器上进行分片与重新组装,这种操作只能在源/目的地执行.如果路由器收到的IPv6数据报因太大而不能转发到出链路上的话,则路由器只需丢掉该数据报,并向发送方发挥一个<code>分组太大</code>的ICMP(互联网控制报文协议)差错报文即可</li>
<li>首部校验和:在网络层中具有该项功能实属多余</li>
<li>选项:可能出现在IPv6首部中由<code>下一首部</code>指出的位置上</li>
</ul>
</li>
</ul>
</li>
<li><p>从IPv4到IPv6的迁移</p>
<ul>
<li>建隧道</li>
</ul>
</li>
</ol>
<h1 id="5-网络层-控制平面"><a href="#5-网络层-控制平面" class="headerlink" title="5 网络层:控制平面"></a>5 网络层:控制平面</h1><h2 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2 路由选择算法"></a>5.2 路由选择算法</h2><ul>
<li>集中式路由选择算法/分散式路由选择算法:链路状态算法(LS),距离向量算法(DV)</li>
<li>静态路由选择算法/动态路由选择算法</li>
<li>负载敏感算法,负载迟钝的(如RIP,OSPF和BGP)</li>
</ul>
<h3 id="5-2-1-链路状态路由选择算法"><a href="#5-2-1-链路状态路由选择算法" class="headerlink" title="5.2.1 链路状态路由选择算法"></a>5.2.1 链路状态路由选择算法</h3><p>初始化:<br>&emsp;$N’=\{u\}$<br>&emsp;对$N$中所有节点$v$:<br>&emsp;&emsp;if ($v$是$u$的邻接节点)<br>&emsp;&emsp;&emsp;$D(v)=c(u,v)$<br>&emsp;&emsp;else<br>&emsp;&emsp;&emsp;$D(v)=\infty$</p>
<p>循环(直到($N==N’$)):<br>&emsp;在$N-N’$中找到$w$满足$D(w)$为最小值<br>&emsp;$N’=N’\cup\{w\}$<br>&emsp;更新$w$的所有不在$N’$中的邻接节点:<br>&emsp;&emsp;$D(v)=\min\{D(v),D(w)+c(w,v)\}$</p>
<h3 id="5-2-2-距离向量路由选择算法"><a href="#5-2-2-距离向量路由选择算法" class="headerlink" title="5.2.2 距离向量路由选择算法"></a>5.2.2 距离向量路由选择算法</h3><p>每个节点$x$维护下列路由选择信息</p>
<ul>
<li><em>对于每个邻居$v$,从$x$到直接相连邻居$v$的开销为$c(x,v)$</em></li>
<li>$x$的距离向量($x$到$N$中所有目的地$y$的开销估计值):$\bm{D}_x=[D_x(y):y\in N]$</li>
<li>$x$的每个邻居$v$的距离向量:$\bm{D}_v=[D_v(y):y\in N]$</li>
</ul>
<p>初始化:<br>&emsp;对$N$中所有节点$y$:<br>&emsp;&emsp;$D_x(y)=c(x,y)$,如果$y$不是$x$的邻接节点,则$D_x(y)=\infty$<br>&emsp;对$x$的所有邻接节点$w$:<br>&emsp;&emsp;对$N$中所有节点$y$:<br>&emsp;&emsp;&emsp;$D_w(y)=?$(<em>$\infty$</em>)<br>&emsp;对$x$的所有邻接节点$w$:<br>&emsp;&emsp;向$w$发送$x$的距离向量$\bm{D}_x$</p>
<p>循环:<br>&emsp;wait (有邻接节点$w$的开销发生变化/收到来自邻接节点$w$的距离向量)<br>&emsp;对$N$中所有节点$y$:<br>&emsp;&emsp;$D_x(y)=\min\{c(x,v)+D_v(y)\}$<br>&emsp;if ($D_x(y)$发生变化)<br>&emsp;&emsp;向所有邻接节点发送距离向量$\bm{D}_x=[D_x:y\in N]$</p>
<h2 id="5-3-因特网中自制系统内部的路由选择-OSPF-开放最短路优先"><a href="#5-3-因特网中自制系统内部的路由选择-OSPF-开放最短路优先" class="headerlink" title="5.3 因特网中自制系统内部的路由选择:OSPF(开放最短路优先)"></a>5.3 因特网中自制系统内部的路由选择:OSPF(开放最短路优先)</h2><ul>
<li>自治系统(AS),自治系统内部路由选择协议</li>
</ul>
<p>OSPF是一种链路状态协议,使用洪泛链路状态信息和Dijkstra最低开销路径算法,各条链路开销是由网络管理员配置的</p>
<p>使用OSPF时,路由器向自治系统内<strong>所有</strong>其他路由器广播路由选择信息,而不仅仅是向其相邻的路由器广播.每当一条链路的状态发生变化时(如开销的变化或连接/中断状态的变化),路由器就会广播链路状态信息.计时链路状态未发生变化,它也要周期性地广播链路状态</p>
<p>OSPF的优点:</p>
<ul>
<li>安全</li>
<li>多条相同开销的路径:当到达某目的地的多条路径具有相同的开销时,OSPF允许使用多条路径(无需仅选择单一的路径来承载所有的流量)</li>
<li>对单播与多播路由选择的综合支持</li>
<li>支持在单个AS中的层次结构</li>
</ul>
<h2 id="5-4-ISP之间的路由选择-BGP-边界网关协议-概念"><a href="#5-4-ISP之间的路由选择-BGP-边界网关协议-概念" class="headerlink" title="5.4 ISP之间的路由选择:BGP(边界网关协议)(概念)"></a>5.4 ISP之间的路由选择:BGP(边界网关协议)(概念)</h2><h3 id="5-4-1-BGP的作用"><a href="#5-4-1-BGP的作用" class="headerlink" title="5.4.1 BGP的作用"></a>5.4.1 BGP的作用</h3><p>在BGP中,分组并不是路由到一个特定的目的地址.相反,时路由到CIDR(无类别域间路由选择)化的前缀,其中每个前缀表示一个子网或一个子网的集合</p>
<h3 id="5-4-2-通告BGP路由信息"><a href="#5-4-2-通告BGP路由信息" class="headerlink" title="5.4.2 通告BGP路由信息"></a>5.4.2 通告BGP路由信息</h3><p>对于每个AS,每台路由器要么是一台网管路由器,要么是一台内部路由器</p>
<p>在BGP中,每队路由器通过使用179端口的半永久TCP连接交换路由选择信息.每条直接连接以及通过该连接发送的BGP报文,称为<strong>BGP连接</strong>.跨越两个AS的BGP连接称为<strong>外部BGP(eBGP)**连接,在相同AS中的两台路由器之间的BGP会话称为</strong>内部BGP(iBGP)**连接</p>
<h3 id="5-4-3-确定最好的路由"><a href="#5-4-3-确定最好的路由" class="headerlink" title="5.4.3 确定最好的路由"></a>5.4.3 确定最好的路由</h3><p>当路由器通过BGP连接通告前缀时,他在前缀中包括一些<strong>BGP属性</strong>,前缀及其属性称为<strong>路由(route)</strong>.每条BGP路由包含3个组件:<code>NEXT-HOP</code>,<code>AS-PATH</code>,目的前缀</p>
<p><code>AS-PATH</code>属性包含了通告已经通过的AS的列表.BGP路由器还使用<code>AS-PATH</code>属性来检测和防止通告环路,如果一台路由器在路径列表中看到包含了他自己的AS,它将拒绝该通告</p>
<p><code>NEXT-HOP</code>是<code>AS-PATH</code>起始的路由器接口的ip地址</p>
<h2 id="5-6-ICMP-因特网控制报文协议"><a href="#5-6-ICMP-因特网控制报文协议" class="headerlink" title="5.6 ICMP:因特网控制报文协议"></a>5.6 ICMP:因特网控制报文协议</h2><p>ICMP被主机和路由器用来彼此沟通网络层的信息.ICMP通常被认为是ip的一部分,但从体系结构上讲它位于ip之上.ICMP报文有一个类型字段和一个编码字段,并且包含引起该ICMP报文首次生成的ip数据报的首部和前8个字节(以便发送方能确定引发该差错的数据报)</p>
<p>ping程序发送一个ICMP类型8编码0的报文到指定主机,看到回显(echo)请求,目的主机发回一个类型0编码0的ICMP回显回答</p>
<p>ICMP报文类型:<strong>TODO</strong></p>
<h1 id="6-链路层和局域网"><a href="#6-链路层和局域网" class="headerlink" title="6 链路层和局域网"></a>6 链路层和局域网</h1><h2 id="6-3-多路访问链路和协议"><a href="#6-3-多路访问链路和协议" class="headerlink" title="6.3 多路访问链路和协议"></a>6.3 多路访问链路和协议</h2><ul>
<li><p>点对点链路</p>
</li>
<li><p>广播链路:能够让多个发送和接收节点都连接到相同的,单一的,共享的广播信道上</p>
</li>
<li><p>多路访问问题,多路访问协议</p>
</li>
<li><p>碰撞(collide):因为所有的节点都能够传输帧,所以多个节点可能会同时传输帧,所有节点同时接到多个帧.这就是说,传输的帧在所有的接收方处碰撞</p>
</li>
</ul>
<p>在理想情况下,对于速率为$R$bps的广播信道,多路访问协议应该具有以下所希望的特性:</p>
<ol>
<li>当仅有一个节点发送数据时,该节点具有$R$bps的吞吐量</li>
<li>当有$M$个节点发送数据时,每个节点在一些适当定义的时间间隔内应该有$R/M$的平均传输速率</li>
<li>协议是分散的:这就是说不会因某主节点故障而是整个系统崩溃</li>
<li>协议是简单的:实现不昂贵</li>
</ol>
<h3 id="6-3-1-信道划分协议"><a href="#6-3-1-信道划分协议" class="headerlink" title="6.3.1 信道划分协议"></a>6.3.1 信道划分协议</h3><ul>
<li><p>时分多路复用(TDM)</p>
</li>
<li><p>频分多路复用(FDM)</p>
</li>
<li><p>码分多址(CDMA)<br>CDMA对每个节点分配一种不同的<strong>编码</strong>,每个节点用它唯一的编码来对他发送的数据进行编码,不同的节点能够<strong>同时</strong>传输</p>
</li>
</ul>
<h3 id="6-3-2-随机接入协议"><a href="#6-3-2-随机接入协议" class="headerlink" title="6.3.2 随机接入协议"></a>6.3.2 随机接入协议</h3><p>当一个节点经历一次碰撞时,它在重发该帧之前等待一个随机时延,涉及碰撞的每个节点独立地选择随机时延</p>
<h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><p>假设:</p>
<ul>
<li>所有帧由$L$比特组成</li>
<li>时间被划分成长度为$L/R$秒的时隙</li>
<li>节点只在时隙起点开始传输帧</li>
<li>节点是同步的,每个节点都知道时隙何时开始</li>
<li>如果在一个时隙中有两个或者更多个帧碰撞,则所有节点在该时隙结束之前检测到该碰撞事件</li>
<li>如果没有碰撞,该节点成功的传输它的帧</li>
<li>如果有碰撞,该节点在时隙结束之前检测到这次碰撞.该节点以概率$p$在后续的每个时隙中重传它的帧,直到该帧被无碰撞地传输出去</li>
</ul>
<p>刚好有一个节点传输的时隙称为一个<strong>成功时隙</strong><br>时隙多路访问协议的<strong>效率</strong>:当有大量活跃节点且每个节点总有大量的帧要发送时,长期运行中成功时隙的份额</p>
<p>一个给定节点成功传送的概率是$p(1-p)^{N-1}$</p>
<h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><p>如果一个传输的帧与一个或多个传输经历了碰撞,这个节点将立即以概率$p$重传该帧</p>
<p>一个给定节点成功传送的概率是$p(1-p)^{2(N-1)}$</p>
<h4 id="载波侦听多路访问-CSMA"><a href="#载波侦听多路访问-CSMA" class="headerlink" title="载波侦听多路访问(CSMA)"></a>载波侦听多路访问(CSMA)</h4><ul>
<li><p>载波侦听</p>
</li>
<li><p>碰撞检测</p>
</li>
<li><p>信道传播时延</p>
</li>
</ul>
<h4 id="具有碰撞检测的载波侦听多路访问-CSMA-CD"><a href="#具有碰撞检测的载波侦听多路访问-CSMA-CD" class="headerlink" title="具有碰撞检测的载波侦听多路访问(CSMA/CD)"></a>具有碰撞检测的载波侦听多路访问(CSMA/CD)</h4><ol>
<li>适配器从网络层获得数据报,准备链路层帧,并将其放入帧适配器缓存中</li>
<li>如果适配器侦听到信道空闲,它开始传输帧.如果适配器侦听到信道正在忙,他将等待,直到侦听到没有信号能量时才开始传输帧</li>
<li>在传输过程中,适配器监视来自其他使用该广播信道的适配器的信号能量的存在</li>
<li>如果适配器在传输时检测到来自其他适配器的信号能量,他中止传输</li>
<li>中止传输后,适配器等待一个随机的时间量,然后返回步骤2</li>
</ol>
<ul>
<li>二进制指数后退算法<br>当传输一个给定帧时,该帧经历了$n$次碰撞后,节点随机地从$\{0, 1, 2, \cdots, 2^n-1\}$中选择一个$K$值<br>对于以太网,一个节点等待的实际时间量是$K\cdot 512$比特时间($K$被发送512比特进入以太网所需的时间量)</li>
</ul>
<h3 id="6-3-3-轮流协议"><a href="#6-3-3-轮流协议" class="headerlink" title="6.3.3 轮流协议"></a>6.3.3 轮流协议</h3><ul>
<li><p>轮询协议</p>
<ul>
<li>轮询时延:每次活跃节点发送了它最多数量的帧时,主节点必须依次轮询每一个非活跃的节点</li>
<li>如果主节点有故障,整个信道都变得不可操作</li>
</ul>
</li>
<li><p>令牌传递协议</p>
<ul>
<li>一个节点的故障可能会使整个信道崩溃</li>
</ul>
</li>
</ul>
<h2 id="6-4-交换局域网"><a href="#6-4-交换局域网" class="headerlink" title="6.4 交换局域网"></a>6.4 交换局域网</h2><h3 id="6-4-1-链路层寻址和ARP"><a href="#6-4-1-链路层寻址和ARP" class="headerlink" title="6.4.1 链路层寻址和ARP"></a>6.4.1 链路层寻址和ARP</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>并不是主机或路由器具有链路层地址,而是他们的适配器(网络接口)具有链路层地址</p>
<p>LAN地址,物理地址,MAC地址</p>
<p>没有两块适配器具有相同的地址</p>
<p>适配器的MAC地址具有扁平结构,不论适配器到哪里都不会变化</p>
<p>当某适配器要向某些目的适配器发送一个帧时,发送适配器将目的适配器的MAC地址插入到该帧中,并将该帧发送到局域网上.一块适配器可以接收一个并非向它寻址的帧.当适配器接收到一个帧时,将检查该帧中的目的MAC地址是否与他自己的MAC地址匹配.如果匹配,该适配器提取出封装的数据报,并将该数据报沿协议栈向上传递.如果不匹配,该适配器丢弃该帧</p>
<ul>
<li>MAC广播地址:<code>FF-FF-FF-FF-FF-FF</code></li>
</ul>
<h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议(ARP)"></a>地址解析协议(ARP)</h4><p>假设交换机广播所有帧</p>
<p>在发送主机中的ARP模块将取在相同局域网上的任何ip地址作为输入,然后返回相应的MAC地址</p>
<p>ARP将一个ip地址解析为一个MAC地址.ARP只为在同一个子网上的主机和路由器接口解析ip地址</p>
<p>每台主机或路由器在其内存中具有一个<strong>ARP表</strong>,这张表包含ip地址到MAC地址的映射关系.从一个表项放置到某ARP表中开始,一个表项通常的过期时间是20分钟</p>
<p>ARP分组有几个字段,包括发送和接收ip地址及MAC地址.ARP查询分组和响应分组都具有相同的格式.ARP查询分组的目的是询问子网上所有其他主机和路由器,以确定对应于要解析的ip地址的那个MAC地址<br>如果ARP表中当前没有目的主机的表项:发送方向它的适配器传递一个ARP查询分组,并且指示适配器应该用MAC广播地址(<code>FF-FF-FF-FF-FF-FF</code>)来发送这个分组.适配器在链路层帧中封装这个ARP分组,用广播地址作为帧的目的地址,并将该帧传输进子网中<br>包含该ARP查询的帧能被子网上所有其他的适配器接收到,并且每个适配器都把在该帧中的ARP分组向上传递给ARP模块.这些ARP模块中的每个都检查它的ip地址是否与ARP分组中的ip地址相匹配.与之匹配的一个给查询主机发送回一个带有所希望映射的相应ARP分组.然后查询主机能够更新它的ARP表</p>
<h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p>一台路由器对它的<strong>每个</strong>接口都有一个ip地址.对路由器的每个接口,在路由器中也有一个ARP模块和一个适配器</p>
<p><strong>具体例子见教材</strong></p>
<h3 id="6-4-2-以太网"><a href="#6-4-2-以太网" class="headerlink" title="6.4.2 以太网"></a>6.4.2 以太网</h3><ul>
<li><p>集线器(hub)</p>
</li>
<li><p>交换机(switch)</p>
</li>
</ul>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="/img/ethernet.png"></p>
<p>发送适配器在一个以太网帧中封装了一个ip数据报,并把该帧传递到物理层</p>
<p>以太网帧的6个字段</p>
<ul>
<li>数据字段(46-1500字节):承载ip数据报.如果ip数据报小于46字节,数据报必须被填充到46字节</li>
<li>目的地地址(6字节):目的适配器的MAC地址</li>
<li>源地址(6字节):传输该帧到局域网上的适配器的MAC地址</li>
<li>类型字段(2字节):允许以太网复用多种网络层协议.ip和其他链路层协议都有各自的标准化的类型编号</li>
<li>CRC(4字节):循环冗余检测</li>
<li>前同步码(8字节):以太网帧以一个8字节的前同步码字段开始.前同步码的前7字节的值都是10101010,最后一个字节是10101011.前同步码字段的前7字节用于唤醒接收适配器,并且将它们的时钟和发送方的时钟同步</li>
</ul>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><ul>
<li>转发器(repeater):是一种物理层设备,能在输入端接收信号并在输出端再生该信号</li>
</ul>
<p>在基于交换机的以太局域网中,不会有碰撞,因此没有必要使用MAC协议了</p>
<h3 id="6-4-3-链路层交换机"><a href="#6-4-3-链路层交换机" class="headerlink" title="6.4.3 链路层交换机"></a>6.4.3 链路层交换机</h3><h4 id="交换机转发和过滤"><a href="#交换机转发和过滤" class="headerlink" title="交换机转发和过滤"></a>交换机转发和过滤</h4><p>交换机表中的表项包括:</p>
<ol>
<li>一个MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项放置在表中的时间</li>
</ol>
<p>假定目的地址为<code>DD-DD-DD-DD-DD-DD</code>的帧从交换机接口$x$到达,交换机用MAC地址<code>DD-DD-DD-DD-DD-DD</code>索引它的表:</p>
<ul>
<li>表中没有对于<code>DD-DD-DD-DD-DD-DD</code>的表项,交换机广播该帧</li>
<li>表中有一个表项将<code>DD-DD-DD-DD-DD-DD</code>与接口$x$联系起来,交换机通过丢弃该帧执行过滤功能即可</li>
<li>表中有一个表项将<code>DD-DD-DD-DD-DD-DD</code>与接口$y\not=x$联系起来,交换机通过将该帧放到接口$y$前面的输出缓存完成转发功能</li>
<li>表中</li>
</ul>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><ol>
<li>交换机表初始为空</li>
<li>对于每个接口接收到的每个入帧,该交换机在其表中存储:<ol>
<li>该帧<strong>源地址</strong>字段中的MAC地址</li>
<li>该帧到达的接口</li>
<li>当前时间</li>
</ol>
</li>
<li>如果在一段时间(老化期)后,交换机没有收到以该地址作为源地址的帧,就在表中删除这个地址</li>
</ol>
<p>交换机时<strong>即插即用设备</strong>,他们不需要网络管理员或用户的干预</p>
<h4 id="链路层交换机的性质"><a href="#链路层交换机的性质" class="headerlink" title="链路层交换机的性质"></a>链路层交换机的性质</h4><ul>
<li><p>消除碰撞:在使用交换机构建的局域网中,没有因碰撞而浪费的带宽.交换机的最大聚合带宽时该交换机所有接口速率之和</p>
</li>
<li><p>异质的链路:交换机将链路彼此隔离,因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行</p>
</li>
<li><p>管理</p>
</li>
</ul>
<h4 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h4><p>交换机</p>
<ul>
<li>优点<ul>
<li>交换机时即插即用的</li>
<li>交换机必须处理到高至第二层(链路层)的帧,路由器必须处理高至第三层(网络层)的帧</li>
</ul>
</li>
<li>缺点<ul>
<li>为了防止广播帧的循环,交换网络的活跃拓普限制为医科生成树</li>
<li>一个大型交换网络将要求在主机和路由器中有大的ARP表,这将生成可观的ARP流量和处理量</li>
</ul>
</li>
</ul>
<p>路由器</p>
<ul>
<li>优点<ul>
<li>网络寻址通常是分层次的,即使网络中存在冗余路径,分组通常也不会通过路由器循环(ip用寿命字段来限制循环).所以,分组不会限制到一颗生成树上,并可以使用源和目的地之间的最佳路径</li>
<li>他们对第二层的广播风暴提供了防火墙保护</li>
</ul>
</li>
<li>缺点<ul>
<li>路由器和连接到他们的主机都需要人为地配置ip地址</li>
<li>路由器对每个分组的处理时间通常比交换机更长</li>
</ul>
</li>
</ul>
<h3 id="6-4-4-虚拟局域网"><a href="#6-4-4-虚拟局域网" class="headerlink" title="6.4.4 虚拟局域网"></a>6.4.4 虚拟局域网</h3><p><strong>TODO</strong></p>
<h1 id="7-无线网络和移动网络"><a href="#7-无线网络和移动网络" class="headerlink" title="7 无线网络和移动网络"></a>7 无线网络和移动网络</h1><h2 id="7-3-Wifi-802-11无线LAN-概念"><a href="#7-3-Wifi-802-11无线LAN-概念" class="headerlink" title="7.3 Wifi:802.11无线LAN(概念)"></a>7.3 Wifi:802.11无线LAN(概念)</h2><p>在IEEE 802.11协议族中几套有关无线LAN的802.11标准都使用相同的媒体访问协议CSMA/CA</p>
<h3 id="7-3-1-802-11-体系结构"><a href="#7-3-1-802-11-体系结构" class="headerlink" title="7.3.1 802.11 体系结构"></a>7.3.1 802.11 体系结构</h3><p>802.11体系结构的基本构建模块是<strong>基本服务集(BSS)</strong>.一个BSS包含一个或多个无线站点和一个称为**接入点(AP)**的中央基站</p>
<p>配置AP的无线LAN经常被称作<strong>基础设施无线LAN</strong>,其中的基础设施是指AP,互联AP和一台路由器的有限以太网</p>
<h4 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h4><p>在802.11中,每个无线站点在能够发送或者接收网络层数据之前,必须与一个AP相<strong>关联</strong></p>
<p>当网络管理员安装一个AP时,管理员为该接入点分配一个单字或双字的<strong>服务集标识符(SSID)</strong></p>
<ul>
<li>Wifi丛林</li>
</ul>
<p>802.11标准要求每个AP周期性地发送<strong>信标帧</strong>,每个信标帧包括该AP的SSID和MAC地址</p>
<p>扫描信道和监听信标帧的过程被称为<strong>被动扫描</strong>.无线主机也能够执行<strong>主动扫描</strong>,这是通过向位于无线主机范围内的所有AP广播探测帧完成的.AP用一个探测响应帧应答探测请求帧.无线主机则能够在响应的AP中选择某AP与之相关联</p>
<p>选定与之关联的AP后,无线主机向AP发送一个关联请求帧,并且该AP以一个关联响应帧进行响应.对于主动扫描需要这种第二次请求/响应握手.一旦与一个AP关联,该主机希望加入该AP所属的子网中,该主机通常将通过关联的AP向该子网发送一个DHCP发现报文(间DHCP协议)以获取在该AP子网中的一个ip地址</p>
<p>为了与特定的AP创建一个关联,某无线站点可能要向该AP鉴别他自身.802.11无线LAN提供了几种不同的鉴别和接入方法</p>
<ol>
<li>基于一个站点的MAC地址允许其接入一个无线网络</li>
<li>应用用户名和口令</li>
</ol>
<h3 id="7-3-2-802-11-MAC协议"><a href="#7-3-2-802-11-MAC协议" class="headerlink" title="7.3.2 802.11 MAC协议"></a>7.3.2 802.11 MAC协议</h3><p>将无线设备或AP称为<strong>站点</strong></p>
<ul>
<li>带碰撞避免的CSMA(CSMA/CA)</li>
</ul>
<p>两种MAC协议的区别</p>
<ul>
<li>802.11使用碰撞避免而非碰撞检测</li>
<li>由于无线信道相对较高的误比特率,802.11使用链路层确认/重传(ARQ)方案</li>
</ul>
<p>802.11<strong>未</strong>实现碰撞检测的原因</p>
<ul>
<li>检测碰撞的能力要求站点具有同时发送和接收的能力.因为在802.11适配器上,接收信号的强度通常远远小于发送信号的强度,制造具有监测碰撞能力的硬件代价较大</li>
<li>适配器会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞</li>
</ul>
<p>由于802.11无线局域网不使用碰撞检测,一旦站点开始发送一个帧,就不会返回</p>
<p>假设一个站点(无线站点或者AP)有一个帧要发送</p>
<ol>
<li>如果某站点最初监听到信道空闲,他将在一个被称作**分布式帧间间隔(DIFS)**的短时间段后发送该帧</li>
<li>否则,该站点选取一个随机回退值,并且在侦听信道空闲时递减该值</li>
<li>当计数值减为0时,该站点发送整个数据帧并等待确认</li>
<li>如果收到确认<ul>
<li>如果要发送另一帧,将从第2步开始CSMA/CA协议</li>
<li>如果未收到确认,发送站点将重新进入第二步中的回退阶段,并从一个更大的范围内选取该随机值</li>
</ul>
</li>
</ol>
<p>802.11的<strong>链路层确认</strong>方案:目的站点收到一个通过CRC校验的帧后,他等待一个称作**短帧间间隔(SIFS)**的一小段时间,然后发回一个确认帧.如果发送站点在给定的时间内未收到确认帧,它假定出现了错误并重传该帧.如果在若干固定次重传后仍未收到确认,发送站点将放弃发送并丢弃该帧</p>
<h4 id="处理隐藏终端-RTS和CTS"><a href="#处理隐藏终端-RTS和CTS" class="headerlink" title="处理隐藏终端:RTS和CTS"></a>处理隐藏终端:RTS和CTS</h4><p>IEEE 802.11协议允许站点使用一个短<strong>请求发送(RTS)**控制帧和一个短</strong>允许发送(CTS)<strong>控制帧来</strong>预约**对信道的访问.当发送方要发送一个DATA帧时,它能够首先向AP发送一个RTS帧,指示传输DATA帧和确认(ACK)帧需要的总时间.当AP收到RTS帧后,他广播一个CTS作为响应:该发送方明确发送许可,指示其他站点在预约期内不要发送</p>
<p>RTS/CTS交换仅仅用于为长数据帧预约信道.每个无线站点可以设置一个RTS门限值,仅当帧长超过门限值时,才使用RTS/CTS序列</p>
<h4 id="使用802-11作为一个点对点链路"><a href="#使用802-11作为一个点对点链路" class="headerlink" title="使用802.11作为一个点对点链路"></a>使用802.11作为一个点对点链路</h4><h3 id="7-3-3-IEEE-802-11帧"><a href="#7-3-3-IEEE-802-11帧" class="headerlink" title="7.3.3 IEEE 802.11帧"></a>7.3.3 IEEE 802.11帧</h3><p><img src="/img/802.11.png"></p>
<ol>
<li><p>有效载荷与CRC字段</p>
</li>
<li><p>地址字段</p>
</li>
<li><p>序号,持续期和帧控制字段</p>
</li>
</ol>
<h3 id="7-3-4-在相同的ip子网中的移动性"><a href="#7-3-4-在相同的ip子网中的移动性" class="headerlink" title="7.3.4 在相同的ip子网中的移动性"></a>7.3.4 在相同的ip子网中的移动性</h3><p><strong>TODO</strong></p>
<h3 id="7-3-5-802-11中的高级特色"><a href="#7-3-5-802-11中的高级特色" class="headerlink" title="7.3.5 802.11中的高级特色"></a>7.3.5 802.11中的高级特色</h3><h3 id="7-3-6-个人域网络-蓝牙和ZigBee"><a href="#7-3-6-个人域网络-蓝牙和ZigBee" class="headerlink" title="7.3.6 个人域网络:蓝牙和ZigBee"></a>7.3.6 个人域网络:蓝牙和ZigBee</h3><ol>
<li><p>蓝牙</p>
</li>
<li><p>ZigBee</p>
</li>
</ol>
<h1 id="9-多媒体网络"><a href="#9-多媒体网络" class="headerlink" title="9 多媒体网络"></a>9 多媒体网络</h1><h2 id="9-1-多媒体网络应用"><a href="#9-1-多媒体网络应用" class="headerlink" title="9.1 多媒体网络应用"></a>9.1 多媒体网络应用</h2><h3 id="9-1-1-视频的性质"><a href="#9-1-1-视频的性质" class="headerlink" title="9.1.1 视频的性质"></a>9.1.1 视频的性质</h3><h3 id="9-1-2-音频的性质"><a href="#9-1-2-音频的性质" class="headerlink" title="9.1.2 音频的性质"></a>9.1.2 音频的性质</h3><h3 id="9-1-3-多媒体网络应用的类型"><a href="#9-1-3-多媒体网络应用的类型" class="headerlink" title="9.1.3 多媒体网络应用的类型"></a>9.1.3 多媒体网络应用的类型</h3><ol>
<li><p>流式存储音频和视频</p>
</li>
<li><p>会话式ip语音和视频</p>
</li>
<li><p>流式实况音频和视频</p>
</li>
</ol>
<h2 id="9-2-流式存储视频"><a href="#9-2-流式存储视频" class="headerlink" title="9.2 流式存储视频"></a>9.2 流式存储视频</h2><h3 id="9-2-1-UDP流"><a href="#9-2-1-UDP流" class="headerlink" title="9.2.1 UDP流"></a>9.2.1 UDP流</h3><h3 id="9-2-2-HTTP流"><a href="#9-2-2-HTTP流" class="headerlink" title="9.2.2 HTTP流"></a>9.2.2 HTTP流</h3><ol>
<li><p>预取视频</p>
</li>
<li><p>客户应用缓存和TCP缓存</p>
</li>
<li><p>流式视频的分析</p>
</li>
</ol>
<p>$B$表示客户应用缓存的长度,$Q$表示客户应用缓存开始播放之前必须被缓存的比特数量,$r$表示视频消耗速率.$t_p,t_f$<strong>TODO</strong></p>
<ol start="4">
<li>视频的早期中止和重定位</li>
</ol>
<h2 id="9-3-ip语音"><a href="#9-3-ip语音" class="headerlink" title="9.3 ip语音"></a>9.3 ip语音</h2><h3 id="9-3-1-尽力而无服务的限制"><a href="#9-3-1-尽力而无服务的限制" class="headerlink" title="9.3.1 尽力而无服务的限制"></a>9.3.1 尽力而无服务的限制</h3><ol>
<li><p>丢包</p>
</li>
<li><p>端到端时延</p>
</li>
<li><p>分组时延抖动</p>
</li>
</ol>
<h3 id="9-3-2-在接收方消除音频的时延抖动"><a href="#9-3-2-在接收方消除音频的时延抖动" class="headerlink" title="9.3.2 在接收方消除音频的时延抖动"></a>9.3.2 在接收方消除音频的时延抖动</h3><ol>
<li><p>固定播放时延</p>
</li>
<li><p>实验性播放时延</p>
</li>
</ol>
<h3 id="9-3-3-从丢包中恢复"><a href="#9-3-3-从丢包中恢复" class="headerlink" title="9.3.3 从丢包中恢复"></a>9.3.3 从丢包中恢复</h3><ol>
<li><p>向前纠错</p>
</li>
<li><p>交织</p>
</li>
<li><p>差错掩盖</p>
</li>
</ol>
<h2 id="9-4-实时会话式应用的协议"><a href="#9-4-实时会话式应用的协议" class="headerlink" title="9.4 实时会话式应用的协议"></a>9.4 实时会话式应用的协议</h2><h3 id="9-4-1-RTP"><a href="#9-4-1-RTP" class="headerlink" title="9.4.1 RTP"></a>9.4.1 RTP</h3><h3 id="9-4-2-SIP"><a href="#9-4-2-SIP" class="headerlink" title="9.4.2 SIP"></a>9.4.2 SIP</h3>

  
<script src="/js/guide.js"></script>

  <script>
    create_guide();
  </script>
</div>

  
<script src="/js/main.js"></script>

  
<script src="/js/search.js"></script>

  
<script src="/js/highlight.js"></script>


</body>

</html>